"""
modules/exploit_manager.py (enhanced)

– Validates exploit module before running
– Caches loaded exploits in memory for reuse
– Exception‐safe, logs all outcomes
"""

import os
import json
import logging
import importlib.util
from pathlib import Path

from bismillah import log_event, CONFIG

logger = logging.getLogger("exploit_manager")
REPO_ROOT = Path(__file__).parent.parent.resolve()
EXPLOIT_LIB_DIR = REPO_ROOT / "modules" / "exploit_lib"
_loaded_exploits = {}

def _load_exploit_module(name: str):
    """
    Load an exploit module once and cache it.
    Enhanced:
      - Supports loading from .pyc/.pyo if .py not found.
      - Supports dynamic reload (force_reload=True).
      - Logs all import attempts and errors.
    """
    force_reload = False
    if name.endswith(":reload"):
        name = name.replace(":reload", "")
        force_reload = True
    if not force_reload and name in _loaded_exploits:
        return _loaded_exploits[name]
    module_path = EXPLOIT_LIB_DIR / f"{name}.py"
    if not module_path.exists():
        # Try .pyc/.pyo
        pyc_path = EXPLOIT_LIB_DIR / f"{name}.pyc"
        pyo_path = EXPLOIT_LIB_DIR / f"{name}.pyo"
        if pyc_path.exists():
            module_path = pyc_path
        elif pyo_path.exists():
            module_path = pyo_path
        else:
            raise FileNotFoundError(f"Exploit {name} not found.")
    logger.info(f"Importing exploit module: {module_path}")
    spec = importlib.util.spec_from_file_location(f"exploit_{name}", str(module_path))
    module_obj = importlib.util.module_from_spec(spec)
    try:
        spec.loader.exec_module(module_obj)
    except Exception as e:
        logger.exception(f"Failed to import exploit {name}: {e}")
        raise
    if not hasattr(module_obj, "exploit"):
        raise AttributeError(f"Exploit {name} does not define exploit()")
    _loaded_exploits[name] = module_obj
    return module_obj

def run_exploit(exploit_name: str, target: str, **kwargs):
    """
    Dynamically run exploit(exploit_name). Returns its dict or error dict.
    Enhanced:
      - Supports batch mode (target can be list).
      - Supports dangerous auto-execution of post_exploit() if present.
      - Logs all actions and errors.
    """
    try:
        module_obj = _load_exploit_module(exploit_name)
        logger.info(f"Running exploit {exploit_name} against {target} with args {kwargs}")
        results = []
        targets = target if isinstance(target, list) else [target]
        for tgt in targets:
            try:
                result = module_obj.exploit(tgt, **kwargs)
            except TypeError:
                result = module_obj.exploit(tgt)
            except Exception as ex:
                logger.exception(f"Exploit {exploit_name} runtime error: {ex}")
                result = {"status":"error","detail":str(ex)}
            # Dangerous: auto-run post_exploit if present
            if hasattr(module_obj, "post_exploit"):
                try:
                    logger.info(f"Running post_exploit for {exploit_name} on {tgt}")
                    post_result = module_obj.post_exploit(tgt, result)
                    result["post_exploit"] = post_result
                except Exception as ex:
                    logger.warning(f"post_exploit failed: {ex}")
            log_event("exploit_manager", f"{exploit_name} on {tgt}: {result}".encode())
            results.append(result)
        return results if len(results) > 1 else results[0]
    except Exception as e:
        logger.error(f"run_exploit error: {e}")
        return {"status":"error","detail":str(e)}

def fetch_latest_exploits():
    """
    Use automatic_cve_fetcher to download latest exploit scripts.
    Enhanced:
      - Supports passing extra args to fetch_exploits.
      - Logs all actions and errors.
    """
    try:
        fetcher_path = EXPLOIT_LIB_DIR / "automatic_cve_fetcher.py"
        spec = importlib.util.spec_from_file_location("automatic_cve_fetcher", str(fetcher_path))
        module_obj = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module_obj)
        repo_url = CONFIG.get("exploit_repo_url")
        extra_args = CONFIG.get("exploit_fetch_args", {})
        logger.info(f"Fetching exploits from {repo_url} with args {extra_args}")
        return module_obj.fetch_exploits(repo_url, **extra_args)
    except Exception as e:
        logger.error(f"fetch_latest_exploits error: {e}")
        return {"status":"error","detail":str(e)}
