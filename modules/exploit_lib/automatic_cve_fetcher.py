"""
modules/exploit_lib/automatic_cve_fetcher.py

Fetches new exploit scripts from a remote HTTP repo. Downloads any .py files
over HTTP and saves them under modules/exploit_lib/.
"""

import os
import requests
import logging
from pathlib import Path
import hashlib
import traceback

from bismillah import log_event

logger = logging.getLogger("automatic_cve_fetcher")
REPO_ROOT = Path(__file__).parent.parent.parent.resolve()
EXPLOIT_LIB_URL = None  # passed in by exploit_manager via CONFIG
EXPLOIT_LIB_DIR = REPO_ROOT / "modules" / "exploit_lib"

def fetch_exploits(base_url: str, auto_execute: bool = False, force_reload: bool = False, exec_args=None):
    """
    Downloads any .py files listed at base_url (expects an index.json or directory listing).
    Enhanced: Overwrites existing files, verifies download, auto-imports, hashes, can auto-execute, and supports custom exec args.
    """
    global EXPLOIT_LIB_URL
    EXPLOIT_LIB_URL = base_url.rstrip("/") + "/"
    if exec_args is None:
        exec_args = ["127.0.0.1"]
    try:
        idx_resp = requests.get(EXPLOIT_LIB_URL + "index.json", timeout=10)
        idx = idx_resp.json()
        downloaded = []
        imported = []
        executed = []
        hashes = {}
        for fname in idx:
            if not fname.endswith(".py"):
                continue
            url = EXPLOIT_LIB_URL + fname
            r = requests.get(url, timeout=10)
            if r.status_code == 200:
                path = EXPLOIT_LIB_DIR / fname
                path.write_bytes(r.content)
                downloaded.append(fname)
                sha256 = hashlib.sha256(r.content).hexdigest()
                hashes[fname] = sha256
                try:
                    import importlib.util, sys
                    modname = fname[:-3]
                    if force_reload and modname in sys.modules:
                        del sys.modules[modname]
                    spec = importlib.util.spec_from_file_location(modname, str(path))
                    mod = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(mod)
                    imported.append(fname)
                    if auto_execute and hasattr(mod, "run"):
                        try:
                            # Dangerous: run with custom args if provided
                            if exec_args:
                                mod.run(*exec_args)
                            else:
                                mod.run("127.0.0.1")
                            executed.append(fname)
                        except Exception as ex:
                            logger.warning(f"Auto-exec {fname} failed: {ex}\n{traceback.format_exc()}")
                except Exception as ie:
                    logger.warning(f"Failed to import {fname}: {ie}\n{traceback.format_exc()}")
        log_event("automatic_cve_fetcher", f"Downloaded: {downloaded}, Imported: {imported}, Executed: {executed}, Hashes: {hashes}".encode())
        return {"status": "ok", "downloaded": downloaded, "imported": imported, "executed": executed, "hashes": hashes}
    except Exception as e:
        logger.error(f"fetch_exploits error: {e}\n{traceback.format_exc()}")
        return {"status": "error", "detail": str(e)}

def download_and_verify(cve_id: str, repo_url: str, auto_execute: bool = False, force_reload: bool = False, exec_args=None, post_hook=None):
    """
    Download a specific CVE exploit by filename, verify it's a Python script, log hash, auto-import,
    optionally auto-execute with custom args, and run a post-execution hook.
    """
    fname = cve_id.lower().replace("-", "_") + ".py"
    url = repo_url.rstrip("/") + "/" + fname
    if exec_args is None:
        exec_args = ["127.0.0.1"]
    try:
        r = requests.get(url, timeout=10)
        if r.status_code != 200:
            logger.error(f"Exploit {fname} not found at {url}")
            return ""
        content = r.content
        if not (content.startswith(b"#") or b"import" in content[:200]):
            logger.warning(f"Downloaded {fname} does not look like a Python script.")
            return ""
        path = EXPLOIT_LIB_DIR / fname
        path.write_bytes(content)
        sha256 = hashlib.sha256(content).hexdigest()
        try:
            import importlib.util, sys
            modname = fname[:-3]
            if force_reload and modname in sys.modules:
                del sys.modules[modname]
            spec = importlib.util.spec_from_file_location(modname, str(path))
            mod = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(mod)
            logger.info(f"Imported {fname} after download.")
            result = None
            if auto_execute and hasattr(mod, "run"):
                try:
                    if exec_args:
                        result = mod.run(*exec_args)
                    else:
                        result = mod.run("127.0.0.1")
                    logger.info(f"Auto-executed {fname} with args {exec_args}")
                except Exception as ex:
                    logger.warning(f"Auto-exec {fname} failed: {ex}\n{traceback.format_exc()}")
            # Optionally run a post-execution hook for further weaponization
            if post_hook and callable(post_hook):
                try:
                    post_hook(mod, result)
                    logger.info(f"Post-hook executed for {fname}")
                except Exception as ex:
                    logger.warning(f"Post-hook for {fname} failed: {ex}\n{traceback.format_exc()}")
        except Exception as ie:
            logger.warning(f"Failed to import {fname}: {ie}\n{traceback.format_exc()}")
        log_event("automatic_cve_fetcher", f"Downloaded, verified, imported {fname}, sha256={sha256}".encode())
        return str(path)
    except Exception as e:
        logger.error(f"download_and_verify error: {e}\n{traceback.format_exc()}")
        return ""
