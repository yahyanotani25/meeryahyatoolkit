/*
 * mem_malware.c (final enhanced)
 *
 * Simple macOS memory‐resident loader: allocates executable memory, writes
 * a “Hello from shellcode” snippet, then transfers execution there.
 * Usage:
 *   gcc mem_malware.c -o mem_malware
 *
 * This code is for demonstration; replace shellcode[] with real bytes.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <errno.h>

/* Minimal shellcode: calls write(1, "Hello", 5); exit(0); for macOS x86_64 */
unsigned char shellcode[] = {
    0x48, 0xc7, 0xc0, 0x04, 0x00, 0x00, 0x02,   /* mov rax,0x2000004 (sys_write) */
    0x48, 0xc7, 0xc7, 0x01, 0x00, 0x00, 0x00,   /* mov rdi,1      (stdout) */
    0x48, 0x8d, 0x35, 0x0e, 0x00, 0x00, 0x00,   /* lea rsi,[rip+0xe] (message) */
    0x48, 0xc7, 0xc2, 0x05, 0x00, 0x00, 0x00,   /* mov rdx,5      (length) */
    0x0f, 0x05,                               /* syscall */
    0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x02,   /* mov rax,0x2000001 (sys_exit) */
    0x48, 0x31, 0xff,                         /* xor rdi,rdi   (exit code 0) */
    0x0f, 0x05,                               /* syscall */
    /* "Hello" string */
    0x48, 0x65, 0x6c, 0x6c, 0x6f
};

int main(int argc, char *argv[])
{
    size_t size = sizeof(shellcode);
    /* Allocate RWX memory */
    void *exec_mem = mmap(NULL, size, PROT_READ | PROT_WRITE | PROT_EXEC,
                          MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (exec_mem == MAP_FAILED) {
        perror("mmap failed");
        return 1;
    }

    /* Copy shellcode */
    memcpy(exec_mem, shellcode, size);

    /* Flush instruction cache if needed */
#if defined(__APPLE__)
    sys_icache_invalidate(exec_mem, size);
#endif

    /* Execute shellcode */
    ((void(*)())exec_mem)();

    /* Should not reach here */
    munmap(exec_mem, size);
    return 0;
}
